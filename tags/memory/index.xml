<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>memory on Baked Bits</title>
    <link>https://mcleary.github.io/tags/memory/</link>
    <description>Recent content in memory on Baked Bits</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Aug 2021 20:05:21 +0100</lastBuildDate><atom:link href="https://mcleary.github.io/tags/memory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Easy Memory Management with the Vulkan Memory Allocator</title>
      <link>https://mcleary.github.io/posts/vulkan-memory-allocator/</link>
      <pubDate>Sun, 22 Aug 2021 20:05:21 +0100</pubDate>
      
      <guid>https://mcleary.github.io/posts/vulkan-memory-allocator/</guid>
      <description>In my post A Simple Vulkan Compute Example in C++ I described the hello world of Vulkan Compute. A very simple application that squares a vector of integers using a HLSL compute shader. It is quite an involved process, requiring many steps to be completed before getting to the actual compute shader execution. You need to:
Create a Vulkan Instance, Physical Device, Logical Device Find the flags required to create a compute Queue Create the buffers that the shader will operate on: Query the memory requirements for a particular buffer Find the index of the memory type to create the buffer from Allocate Memory for the buffers Map the memory and fill it with the data you want Bind the buffers to the memory Create a Descriptor Set, Shader Module, Pipeline Create a Command Pool, Command Buffer, Fences Dispatch the shader Wait for completion Map the buffers and read the results back It is a rather complex process just to run some program on your GPU.</description>
    </item>
    
  </channel>
</rss>
